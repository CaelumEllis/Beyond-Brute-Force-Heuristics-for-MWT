
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

#include "load_coordinates.h"
#include "CandidateEdgeFilter.h"
#include "SimulatedAnnealing.h"
#include "DelaunayWrapper.h"
#include "GraphState.h"
#include "FlipCriteria.h"

int main(int argc, char** argv) {

    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <dataset_file>\n";
        return 1;
    }

    std::string filename = argv[1];

    // Load points/vertices from file
    auto coordinates = loadCoordinatesFromFile(filename);
    std::vector<std::pair<double,double>> pointPairs;
    pointPairs.reserve(coordinates.size());

    for (const auto& c : coordinates)
        pointPairs.emplace_back(c.x, c.y);

    //  Returns Delaunay triangulation in DTResult format
    auto dt = DelaunayWrapper::translateOutput(pointPairs);
    GraphState gs(dt, pointPairs);

    std::cout << "\n=====================================\n";
    std::cout << "   Initial Delaunay Triangulation\n";
    std::cout << "=====================================\n";
    std::cout << "Points: " << gs.points.size() << "\n";
    std::cout << "Edges:  " << gs.edges.size()  << "\n";

    // Generates initial candidate edge list
    auto candidateEdges = CandidateEdgeFilter::buildCandidateSet(gs);

    double cnt = 0;
    for (auto& e : candidateEdges) {
        if (FlipCriteria::isFlipLegal(gs, e.u, e.v).legal)
            cnt++;
    }

    std::cout << "\nInitial Candidate Edge Count: " << candidateEdges.size() << "\n";
    std::cout << "Legal flips available: " << cnt << "\n";

    std::cout << "\n=====================================\n";
    std::cout << "   Running Simulated Annealing...\n";
    std::cout << "=====================================\n";

    SimulatedAnnealing sa;
    sa.initialTemperature = 1.0;
    sa.minTemperature     = 1e-6;
    sa.coolingRate        = 0.9995;
    sa.maxIterations      = 200000;

    std::cout << "Initial Weight: " << sa.computeWeight(gs) << "\n";
    sa.run(gs);
    // sa.greedyImprove(gs);
    std::cout << "Final Weight:   " << sa.computeWeight(gs) << "\n";
    // ---- Print Final Output ----
    // std::cout << "\n=====================================\n";
    // std::cout << "   Final Graph After Annealing\n";
    // std::cout << "=====================================\n";
    //
    // for (const auto& e : gs.edges)
    //     std::cout << "(" << e.u << "," << e.v << ") len=" << e.weight << "\n";

    std::cout << "\nDone.\n";
    return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////
// // Used to print the edges returned by SimpleDelaunay and the triangulation generated by it//
// //////////////////////////////////////////////////////////////////////////////////////
// int main(int argc, char** argv) {
//     if (argc < 2) {
//         std::cerr << "Usage: " << argv[0] << " <dataset_file>\n";
//         return 1;
//     }
//     std::string filename = argv[1];
//
//     auto coordinates = loadCoordinatesFromFile(filename);
//
//     // Convert into std::pair<double,double> format
//     std::vector<std::pair<double,double>> pointPairs;
//     pointPairs.reserve(coordinates.size());
//
//     for (const auto& c : coordinates) {
//         pointPairs.emplace_back(c.x, c.y);
//     }
//
//     // returns DTResult which is the set of edges and triangles of the Delaunay triangulation computed by SimpleDelaunay
//     // Delaunay triangulation computed by SimpleDelaunay in average O(nlogn) runtime
//     auto DTResult = DelaunayWrapper::translateOutput(pointPairs);
//
//     // put triangulation and edges into a GraphState
//     GraphState gs(DTResult, pointPairs);
//
//     // ---- Debug print ----
//     std::cout << "Delaunay Graph built.\n";
//     std::cout << "Points: " << gs.points.size() << "\n";
//     std::cout << "Edges: " << gs.edges.size() << "\n";
//     std::cout << "Triangles: " << gs.triangles.size() << "\n\n";
//
//     std::cout << "Edges:\n";
//     for (auto &e : gs.edges) {
//         std::cout << "(" << e.u << "," << e.v << ") len=" << e.weight << "\n";
//     }
//
//     return 0;
// }


// ////////////////////////////////////////////////////////////////////////////////////
//  Only Use to confirm that the data is loaded correctly into a coordinate vector   //
// ////////////////////////////////////////////////////////////////////////////////////
// int main(int argc, char** argv) {
//     if (argc < 2) {
//         std::cerr << "Usage: " << argv[0] << " <dataset_file>\n";
//         return 1;
//     }
//
//     std::string filename = argv[1];
//
//     try {
//         auto coordinates = loadCoordinatesFromFile(filename);
//
//         std::cout << "Loaded " << coordinates.size() << " coordinates:\n";
//         for (const auto& p : coordinates) {
//             std::cout << "(" << p.x << ", " << p.y << ")\n";
//         }
//
//     } catch (const std::exception& e) {
//         std::cerr << e.what() << "\n";
//         return 1;
//     }
//
//     return 0;
// }
//////////////////////////////////////////////////////////////////////////////////////